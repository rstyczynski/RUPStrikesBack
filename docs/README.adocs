= RUP Strikes Back: Agentic Programming Cooperation Model
:author: Ryszard Styczynski
:revdate: 2025-11-12
:toc: left
:toc-title: Table of Contents
:toclevels: 3
:imagesdir: images

== Overview

The Agentic Programming Cooperation Model represents a collaborative framework where a Product Owner and an AI Agent work together through a structured software development process. The model emphasizes clear communication, iterative refinement, and formal quality gates to ensure both parties remain aligned throughout the project lifecycle.

At its core, this model establishes a partnership built on explicit specifications and review cycles. Rather than ad-hoc interactions, the collaboration follows a defined pathway that moves from establishing working agreements, through requirements definition and design, to final implementation. Each transition point requires explicit acceptance, ensuring nothing moves forward until both parties agree the current stage meets quality standards.

The terminology deliberately borrows from multiple methodological traditions. The Product Owner role comes from Scrum, representing the person who holds the vision for what needs to be built and maintains authority over requirements and acceptance criteria. This choice reflects that agentic programming isn't purely technical—it requires someone with product thinking and decision-making authority to guide the AI effectively. Unlike traditional Scrum where the Product Owner works with a human development team, here they work directly with an AI Agent, requiring even more explicit communication and formal specifications.

Scrum's emphasis on defined roles and adaptive iteration complements the agentic model by preserving human decision authority while allowing the AI to iterate rapidly within explicit acceptance criteria. This structure ensures that while the AI accelerates delivery, the Product Owner maintains strategic control and quality oversight.

=== Project Organization

The collaboration uses structured artifacts: **Backlog** defines what to build, **Plan** organizes work into Sprints (iterations), and **Progress Board** tracks status. Each Sprint progresses through defined states (Planned → Progress → Designed → Implemented → Tested → Done), with execution modes supporting both interactive (managed) and autonomous (YOLO) workflows.

== The Return of Structured Methodology in the Age of AI

Interestingly, this model resurrects principles from the Rational Unified Process (RUP) that many developers thought had been permanently replaced by agile methodologies. RUP, which emerged in the late 1990s and early 2000s, emphasized formal phases - `Inception`, `Elaboration`, `Construction`, and `Transition` - along with comprehensive documentation and explicit phase gates. As agile methodologies gained dominance in the 2010s, these structured approaches fell out of favor, dismissed as too heavyweight and bureaucratic for fast-moving software teams.

However, working with AI agents creates a fundamentally different dynamic that makes RUP-like structure surprisingly relevant again. When collaborating with an AI, explicit documentation isn't bureaucratic overhead - it's the primary communication medium. Unlike human team members who can infer context, understand implicit requirements, and course-correct through casual conversation, AI agents require precision and explicitness to function effectively. The formality that seemed excessive in human-to-human collaboration becomes essential in human-to-AI collaboration.

[.text-center]
image::Development-iterative.png[Iterative and incremental software development, width=600]
_Figure 1: Iterative development cycle. Structured methods like RUP bring formal review loops to every phase, providing clear gates for human-AI collaboration._

The phase names themselves - `Inception`, `Elaboration`, `Construction` - echo RUP deliberately. This isn't coincidence but recognition that these phases represent natural boundaries in the design and development process. What's different is the addition of the Contracting phase, which has no direct RUP equivalent. This phase acknowledges that before any project work begins, the human and AI must establish a shared understanding of how they'll work together. This meta-level agreement about collaboration protocols, documentation standards, and feedback mechanisms creates the foundation for effective partnership.

RUP was often criticized for its documentation-heavy approach, but in agentic programming, documentation serves a different purpose. Rather than creating artifacts for compliance or future maintenance, documents become active collaboration tools. The Software Requirements Specification isn't filed away - it's read, analyzed, and questioned by the Agent. The Design document isn't a one-way communication - it evolves through explicit review cycles where both parties contribute. Documentation transforms from a burden into a dialogue.

The iterative nature of RUP also finds new relevance. Each phase's review loop allows for refinement without chaos, providing structured opportunities for the Agent to request clarifications or point out inconsistencies. This formalized iteration prevents the drift and misalignment that can occur when working with AI through informal, ad-hoc interactions. The phase gates ensure that foundational issues are resolved before they cascade into later stages, a principle RUP championed that becomes even more critical when one party in the collaboration is an AI system.

What's emerging is a synthesis: the structure and formality of RUP adapted for the unique requirements of human-AI collaboration, combined with the iterative refinement and feedback loops that modern development practices value. Agentic programming doesn't simply resurrect old methodologies - it demonstrates that certain principles remain valid regardless of who (or what) you're collaborating with, as long as they're applied with understanding of the collaboration context.

== Pair Programming Reimagined

Perhaps the most apt comparison comes from Extreme Programming (XP) and its practice of pair programming. In traditional XP, two developers work together at one workstation - the "driver" writes code while the "navigator" reviews each line, thinks strategically, and catches errors in real-time. This constant dialogue and immediate feedback loop was meant to improve code quality, spread knowledge, and reduce defects.

Agentic programming is essentially pair programming evolved for the AI age. The Product Owner takes the navigator role - providing direction, reviewing output, and making strategic decisions - while the Agent acts as the driver, translating requirements into design and code. But unlike traditional pair programming where both parties share relatively equal technical capability, this partnership involves an asymmetry: the human excels at high-level reasoning, context understanding, and goal-setting, while the AI excels at rapid implementation, pattern recognition, and systematic execution.

What XP got right was recognizing that software development benefits from continuous collaboration and real-time feedback rather than disconnected, asynchronous handoffs. The review loops in each phase of the Agentic Programming model embody this principle - the Product Owner and Agent remain in constant dialogue through formal review cycles, catching issues immediately rather than discovering them weeks later. The difference is that instead of sitting side-by-side at one machine, the collaboration happens through structured documents and explicit acceptance gates, adapted to the realities of working with an AI partner.

XP's pair programming also emphasized shared understanding and collective code ownership. In agentic programming, this manifests as the Agent questioning unclear requirements and the Product Owner reviewing and refining Agent-generated designs. Neither party works in isolation; both contribute to the final product's quality through their respective strengths. The formal structure doesn't eliminate the collaborative spirit of XP - it channels it through protocols that work effectively across the human-AI boundary.

Where XP's human pairs exchanged tacit understanding through conversation, agentic pairs exchange structured artifacts - specifications, reviews, and design updates. The medium changes from spontaneous discussion to formalized documentation, but the spirit of continuous mutual review and shared ownership remains unchanged.

== The Dream Comes True

In 2008, I established a vision of combining software delivery methods to take the best from each level - organization (RUP/OUM), team (Scrum), and programmer (XP); the original file is available link:refs/OUM,%20SCRUM,%20and%20XP%20-%20combined%20for%20flexible%20solution%20delivery,%20version%205.pdf[here]. This vision, which seemed idealistic at the time, now comes to reality with the agentic shift in software development. The AI agent becomes the perfect partner for this synthesis: it can follow RUP's structured phases, respond to Scrum's Product Owner direction, and engage in XP's pair programming practices - all simultaneously.

|===
| Level | Human-AI Equivalent | Reference Methodology

| Organizational | Phase governance, formal reviews | RUP / OUM
| Team | Product Owner guidance, adaptive iteration | Scrum
| Individual | Continuous collaboration and review | Extreme Programming (XP)
|===

This multi-layer synthesis integrates structure, adaptability, and collaboration into one coherent delivery model.

The following diagram illustrates this vision — how structured, team, and individual-level methodologies align naturally within the agentic collaboration paradigm.

[.text-center]
image::oum_scrum_xp.png[RUP, Scrum, and XP combined together, width=400]
_Figure 2: The 2008 vision of combining methodologies at different levels - now realized through human-AI collaboration_

== The Collaboration Journey

=== Contracting Phase

The journey begins with `contracting`, where the Product Owner establishes the ground rules for how they'll work with the Agent. This isn't just about technical constraints - it's about setting expectations for communication, documentation standards, and feedback mechanisms. The Product Owner crafts an Agent Cooperation Specification (ACS) that outlines technology constraints, coding and testing standards, and defines how requirements, design documents, and feedback should be structured.

The Agent reviews this specification and either accepts it or points out unclear or problematic elements. This back-and-forth continues until both parties have a shared understanding of the collaboration framework.

[mermaid, format=svg]
----
flowchart LR
    Start([Project Started]) --> C1

    subgraph Contracting["<b>CONTRACTING PHASE</b>"]
        direction LR
        C1[Product Owner<br/>creates ACS]
        C2[Product Owner<br/>requests ACS<br/>acceptance]
        C3[Agent<br/>reads ACS]
        C4{ACS<br/>accepted?}

        C1 --> C2 --> C3 --> C4
        C4 -->|no| C2
    end

    C4 -->|yes| Next([Continue to Inception])

    style Contracting fill:#e8e8e8
    style C3 fill:#ffcccc
    style C4 fill:#ffcccc
----

=== Inception Phase

Once the cooperation framework is solid, the process moves into `inception`. Here, the Product Owner translates their vision into a concrete Software Requirements Specification (SRS). This document captures the project goals, functional requirements, and non-functional requirements that define what needs to be built. The Agent carefully reviews this specification, identifying any errors, ambiguities, or areas where more information is needed. The Agent organizes its feedback into dedicated chapters - one for proposed changes addressing errors, another for clarification requests. This structured feedback helps the Product Owner refine the requirements until they're clear, complete, and implementable.

[mermaid, format=svg]
----
flowchart LR
    From([From Contracting]) --> I1

    subgraph Inception["<b>INCEPTION PHASE</b>"]
        direction LR
        I1[Product Owner<br/>creates SRS]
        I2[Product Owner<br/>requests SRS<br/>acceptance]
        I3[Agent<br/>reads SRS]
        I4{SRS<br/>accepted?}

        I1 --> I2 --> I3 --> I4
        I4 -->|no| I2
    end

    I4 -->|yes| Next([Continue to Elaboration])

    style Inception fill:#d4edda
    style I3 fill:#ffcccc
    style I4 fill:#ffcccc
----

=== Elaboration Phase

With requirements solidified, `elaboration` begins. The Product Owner requests that the Agent create a detailed design showing how the system will be built. The Agent develops implementation details, architectural decisions, and technical specifications. The Product Owner then reviews this design, and if changes are needed, enumerates them by updating the design documentation. This creates a clear record of design evolution and ensures the Agent understands exactly what modifications are required. The cycle continues until the Product Owner accepts the proposed approach.

[mermaid, format=svg]
----
flowchart LR
    From([From Inception]) --> E1

    subgraph Elaboration["<b>ELABORATION PHASE</b>"]
        direction LR
        E1[Product Owner<br/>requests design]
        E2[Agent<br/>creates design]
        E3[Product Owner<br/>reviews design]
        E4{Design<br/>accepted?}

        E1 --> E2 --> E3 --> E4
        E4 -->|no| E2
    end

    E4 -->|yes| Next([Continue to Construction])

    style Elaboration fill:#fff3cd
    style E2 fill:#ffcccc
----

=== Construction Phase

The construction phase brings the design to life. The Product Owner requests `implementation`, and the Agent builds the solution while ensuring comprehensive test coverage. This includes functional unit tests to verify behavior, performance tests to ensure efficiency, and crash or overload tests to validate robustness. When the Product Owner reviews the implementation, any issues discovered are documented by updating the design chapter, creating traceability between problems and their context. The Agent addresses these issues, and the review cycle continues until the Product Owner accepts the delivered product.

[mermaid, format=svg]
----
flowchart LR
    From([From Elaboration]) --> Co1

    subgraph Construction["<b>CONSTRUCTION PHASE</b>"]
        direction LR
        Co1[Product Owner<br/>requests<br/>implementation]
        Co2[Agent<br/>implements]
        Co3[Product Owner<br/>reviews<br/>implementation]
        Co4{Product<br/>accepted?}

        Co1 --> Co2 --> Co3 --> Co4
        Co4 -->|no| Co2
    end

    Co4 -->|yes| Final{All phases<br/>implemented?}
    Final -->|no| Back([Return to Inception])
    Final -->|yes| End([Project Finished])

    style Construction fill:#d1ecf1
    style Co2 fill:#ffcccc
----

=== Phase Integration

Throughout all phases, the model maintains formal review loops. These aren't bureaucratic obstacles but rather opportunities for course correction and quality assurance. Each loop allows the Product Owner to provide specific, actionable feedback while the Agent demonstrates its understanding through revisions. The Agent's role shifts appropriately across phases - from validator and questioner during specification phases to creator and implementer during design and construction.

==== Phase Feedback Loop Summary

An essential practice within each review loop is capturing chat summaries as project documentation. At the conclusion of each review iteration, the Product Owner or Agent should generate a summary of the discussion, capturing key decisions made and their rationale, questions raised and their answers, issues identified and how they were resolved, design alternatives considered and rejected, and clarifications that refined understanding.

Chat summaries are committed to the repository as markdown files in `progress/sprint_<id>/` directories, organized by phase e.g.:

* `progress/sprint_15/sprint_15_contract.md`, 
* `progress/sprint_15/sprint_15_analysis.md`,
* `progress/sprint_15/sprint_15_design.md`,
* `progress/sprint_15/sprint_15_implementation.md`. 

This creates a living knowledge base that provides several critical benefits.

Enhanced traceability emerges naturally from this practice. Future developers, whether human or AI, can understand not just what was decided, but why certain choices were made. The dialogue that led to specific design decisions becomes permanently accessible, preventing the loss of context that typically occurs in verbal or transient conversations.

Team knowledge building follows as a natural consequence. When multiple Product Owners or team members work on related projects, these summaries serve as a collective memory. Patterns emerge across projects - common pitfalls identified, successful approaches validated, domain understanding deepened. The repository becomes not just a code base but a knowledge base.

Continuity across sessions becomes possible through these documented conversations. AI agents, while powerful within a session, don't maintain context between separate engagements. Chat summaries allow new agent sessions to rapidly reconstruct understanding by reading previous dialogues. Similarly, if a different Agent takes over work, the historical summaries provide essential context that would otherwise be lost.

A quality audit trail materializes as these summaries accumulate. For compliance or quality assurance purposes, the chat summaries demonstrate thorough review processes and thoughtful consideration of requirements. They show that specifications weren't blindly implemented but carefully examined and refined through structured dialogue.

The practice of recording these summaries transforms ephemeral conversations into persistent project assets. What might otherwise vanish at session's end becomes documented institutional knowledge, enriching both immediate project understanding and long-term organizational learning.

The process concludes only when all phases have been successfully completed and accepted. This ensures no shortcuts compromise quality and that the final product reflects a true partnership between human vision and AI capability.

=== Final documentation check

Each phase is responsible for building own documentation, however at the end one more documentation check phase is executed, what is executed by `agent-documentor` agent.

== Version Control and Git Workflow

Version control plays a vital role in the agentic programming collaboration model. Each phase completion after closing its review loop is marked with a commit, creating clear checkpoints in the project history. Similarly, each work session completed by the Agent concludes with a commit, ensuring incremental progress is captured.

The Agent provides detailed commit messages following semantic commit conventions, making the repository history a valuable documentation trail. Project versions follow semantic versioning principles, with version increments tied to accepted phase completions. This approach creates a clear relationship between project milestones and version numbers, allowing both parties to understand the project's evolution at any point in its history.

== Key Success Factors

In agentic programming, discipline returns - not as bureaucracy, but as the grammar of cooperation between human intent and machine execution. Agentic work without discipline can easily devolve into anarchy - much like 'agile' practices without structure and rules.

[.text-center]
image::agile_anarchy.png[Agile Anarchy, width=400]
_Figure 3: Agile Anarchy (from Stacey Matrix). Source: Strategic Management and Organizational Dynamics by Ralph Stacey in Agile Software Development with Scrum by Ken Schwaber and Mike Beedle._

Success in this model depends on clear role separation and mutual accountability. The Product Owner maintains authority over specifications and acceptance decisions while providing structured feedback that guides improvement. The Agent takes responsibility for identifying specification gaps, creating quality designs, and delivering well-tested implementations while requesting clarifications when needed.

Documentation serves as the collaboration backbone, creating shared artifacts that both parties can reference and refine. Each document evolves through its review loop, becoming progressively more precise and complete. This documentation trail also provides valuable context for future phases and serves as a record of decisions made throughout the project.

The model's iterative nature acknowledges that perfection rarely emerges on the first attempt. By building in explicit review cycles and structured feedback mechanisms, it creates space for refinement without creating chaos. Both parties know what to expect at each stage and how to communicate effectively when revisions are needed.

In many ways, agentic programming brings software engineering full circle.
The rigor once reserved for safety-critical systems now becomes necessary for everyday collaboration with autonomous systems.

Agentic programming doesn't reinvent engineering - it reconciles rigor with agility. Structure no longer constrains creativity; it anchors trust between human intent and machine execution.


[.text-center]
\###
